<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sci-Fi City with Three.js</title>
    <style>
      body {
          margin: 0;
          overflow: hidden;
          background-color: #000;
      }
      canvas {
          display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
      // Initialize scene, camera, and renderer
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a2a); // Dark background
      scene.fog = new THREE.Fog(0x0a0a2a, 200, 1000); // Fog for depth

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
      camera.position.set(0, 100, 200);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0x404080, 0.5);
      scene.add(ambientLight);

      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 200, 100);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // Add neon point lights
      const neonLight1 = new THREE.PointLight(0x0066ff, 1, 200);
      neonLight1.position.set(50, 50, 50);
      scene.add(neonLight1);

      const neonLight2 = new THREE.PointLight(0xff00ff, 1, 200);
      neonLight2.position.set(-50, 50, -50);
      scene.add(neonLight2);

      // Create buildings
      const buildingGeometry = new THREE.BoxGeometry(10, 50, 10);
      const buildingMaterial = new THREE.MeshStandardMaterial({
          color: 0x333355,
          metalness: 0.2,
          roughness: 0.8,
      });

      // Create a grid of buildings
      for (let x = -200; x <= 200; x += 30) {
          for (let z = -200; z <= 200; z += 30) {
              const building = new THREE.Mesh(buildingGeometry, buildingMaterial.clone());
              building.position.set(x, 25, z);

              // Randomize building height and color
              building.scale.y = 1 + Math.random() * 10;
              building.material.color.setHex(0x333355 + Math.floor(Math.random() * 0x222222));

              // Add emissive glow to some buildings
              if (Math.random() > 0.7) {
                  building.material.emissive = new THREE.Color(0x0066ff);
                  building.material.emissiveIntensity = 0.5;
                  building.material.needsUpdate = true;
              }

              scene.add(building);
          }
      }

      // Neon signs
      const signGeometry = new THREE.PlaneGeometry(15, 5);
      const signMaterial = new THREE.MeshStandardMaterial({
          color: 0x00ffff,
          emissive: 0x00ffff,
          emissiveIntensity: 2,
          side: THREE.DoubleSide,
      });

      // Add signs to random buildings
      for (let i = 0; i < 20; i++) {
          const sign = new THREE.Mesh(signGeometry, signMaterial);
          sign.position.set(
              -200 + Math.random() * 400,
              10 + Math.random() * 40,
              -200 + Math.random() * 400
          );
          sign.rotation.y = Math.random() * Math.PI * 2;
          scene.add(sign);
      }

      // Create streets
      const roadTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/grid.png');
      roadTexture.wrapS = THREE.RepeatWrapping;
      roadTexture.wrapT = THREE.RepeatWrapping;
      roadTexture.repeat.set(10, 10);

      const streetWidth = 400;
      const streetLength = 400;
      const streetGeometry = new THREE.PlaneGeometry(streetWidth, streetLength);
      const streetMaterial = new THREE.MeshStandardMaterial({
          map: roadTexture,
          color: 0x222222,
          roughness: 0.9,
      });
      const street = new THREE.Mesh(streetGeometry, streetMaterial);
      street.rotation.x = -Math.PI / 2;
      street.position.y = -0.1;
      scene.add(street);

      // Add street lights
      const streetLightGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 8);
      const streetLightMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

      for (let z = -200; z <= 200; z += 20) {
          // Left side of the street
          const lightPoleLeft = new THREE.Mesh(streetLightGeometry, streetLightMaterial);
          lightPoleLeft.position.set(-90, 2.5, z);
          scene.add(lightPoleLeft);

          const lightBulbLeft = new THREE.Mesh(
              new THREE.SphereGeometry(0.8, 8, 8),
              new THREE.MeshStandardMaterial({
                  color: 0xffffaa,
                  emissive: 0xffffaa,
                  emissiveIntensity: 2,
              })
          );
          lightBulbLeft.position.set(-90, 5, z);
          scene.add(lightBulbLeft);

          const pointLightLeft = new THREE.PointLight(0xffffaa, 1, 20);
          pointLightLeft.position.set(-90, 5, z);
          scene.add(pointLightLeft);

          // Right side of the street
          const lightPoleRight = new THREE.Mesh(streetLightGeometry, streetLightMaterial);
          lightPoleRight.position.set(90, 2.5, z);
          scene.add(lightPoleRight);

          const lightBulbRight = new THREE.Mesh(
              new THREE.SphereGeometry(0.8, 8, 8),
              new THREE.MeshStandardMaterial({
                  color: 0xffffaa,
                  emissive: 0xffffaa,
                  emissiveIntensity: 2,
              })
          );
          lightBulbRight.position.set(90, 5, z);
          scene.add(lightBulbRight);

          const pointLightRight = new THREE.PointLight(0xffffaa, 1, 20);
          pointLightRight.position.set(90, 5, z);
          scene.add(pointLightRight);
      }

      // Flying vehicles
      const vehicleGeometry = new THREE.BoxGeometry(5, 1, 3);
      const vehicleMaterial = new THREE.MeshStandardMaterial({
          color: 0x5555ff,
          emissive: 0x00aaaa,
          emissiveIntensity: 0.5,
      });

      // Spawn flying vehicles
      for (let i = 0; i < 10; i++) {
          const vehicle = new THREE.Mesh(vehicleGeometry, vehicleMaterial);
          vehicle.position.set(
              -150 + Math.random() * 300,
              20 + Math.random() * 50,
              -150 + Math.random() * 300
          );
          scene.add(vehicle);
      }

      // Particle system for floating holograms
      const particleGeometry = new THREE.BufferGeometry();
      const particles = 500;
      const posArray = new Float32Array(particles * 3);

      for (let i = 0; i < particles * 3; i++) {
          posArray[i] = (Math.random() - 0.5) * 400;
      }
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

      const particleMaterial = new THREE.PointsMaterial({
          color: 0x00ffff,
          size: 0.5,
          transparent: true,
          opacity: 0.8,
      });

      const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particleSystem);

      // OrbitControls for exploration
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Animation loop
      function animate() {
          requestAnimationFrame(animate);

          // Animate flying vehicles
          scene.children.forEach(child => {
              if (child.geometry === vehicleGeometry) {
                  child.position.z += 0.1;
                  if (child.position.z > 200) {
                      child.position.z = -200;
                  }
              }
          });

          controls.update();
          renderer.render(scene, camera);
      }
      animate();

      // Handle window resizing
      window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
